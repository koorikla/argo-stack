argocd-apps:
  enabled: true
  fullnameOverride: argocd-apps
  applications:
    # Argo can manage argo itself, thanks to its stateless nature we always have backwards compatability with helm disaster recovery is to fix and run helm upgrade --install argo helm/argo -n argo
    argo:
      namespace: argo
      project: infra
      sources:
      - repoURL: https://github.com/koorikla/argo-stack
        path: helm/argo
        targetRevision: main
      destination:
        server: https://kubernetes.default.svc
        namespace: argo
      syncPolicy:
        automated:
          prune: true
          selfHeal: true

    cert-manager:
      namespace: argo
      project: infra
      source:
        repoURL: https://charts.jetstack.io
        targetRevision: 1.*.*
        chart: cert-manager
        helm:
          parameters:
            - name: crds.enabled
              value: 'true'
      destination:
        server: https://kubernetes.default.svc
        namespace: kube-system
      syncPolicy:
        automated:
          prune: true
          selfHeal: true

    crossplane:
      namespace: argo
      project: infra
      sources:
      - repoURL: https://github.com/koorikla/argo-stack
        path: helm/crossplane
        targetRevision: main
      destination:
        server: https://kubernetes.default.svc
        namespace: crossplane-system
      syncPolicy:
        syncOptions:
        - CreateNamespace=true

    kargo:
      namespace: argo
      project: infra
      sources:
      - repoURL: https://github.com/koorikla/argo-stack
        path: helm/kargo
        targetRevision: main
      destination:
        server: https://kubernetes.default.svc
        namespace: kargo
      syncPolicy:
        syncOptions:
        - CreateNamespace=true

    workflow-components:
      namespace: argo
      project: demo
      sources:
      - repoURL: https://github.com/koorikla/argo-stack
        path: workflow-components
        targetRevision: main
        directory:
          recurse: true
      destination:
        server: https://kubernetes.default.svc
        namespace: argo

    any-manifest:
      namespace: argo
      project: demo
      sources:
      - repoURL: https://github.com/koorikla/argo-stack
        path: manifests
        targetRevision: main
        directory:
          recurse: true
      destination:
        server: https://kubernetes.default.svc
        namespace: default

    rollout-demo:
      namespace: argo
      project: demo
      sources:
      - repoURL: https://github.com/koorikla/argo-stack
        path: rollout-demo
        targetRevision: main
        directory:
          recurse: true
      destination:
        server: https://kubernetes.default.svc
        namespace: default

  projects:
    infra:
      namespace: argo
      finalizers:
      description: Infra Project
      sourceRepos:
      - '*'
      destinations:
      - namespace: '*'
        server: https://kubernetes.default.svc
      clusterResourceWhitelist:
      - group: '*'
        kind: '*'

    demo:
      namespace: argo
      finalizers:
      description: Infra Project
      sourceRepos:
      - '*'
      destinations:
      - namespace: '*'
        server: https://kubernetes.default.svc
      clusterResourceWhitelist:
      - group: '*'
        kind: '*'



argo-cd:
  enabled: true
  fullnameOverride: argo-cd
  global:
    domain: argocd.local

  configs:
    params:
      server.insecure: true


  server:
    httproute:
      enabled: true
      parentRefs:
        - name: external
          namespace: argo
          sectionName: https
  # server:
  #   ingress:
  #     enabled: false
    # Experimental Gateway API support
    # See https://artifacthub.io/packages/helm/argo/argo-cd#gateway-api
    # This requires the Gateway API CRDs to be installed on the cluster
    # and a Gateway resource to be created.
    # We are creating the Gateway in manifests/gateway.yaml
    # and applying it in the Makefile init step.
    # Note: `server.httproute` configuration structure depends on chart version.
    # Assuming modern chart structure based on typical Gateway API implementations.
    # If the chart doesn't support httproute block directly, we might need a raw manifest.
    # Checking values structure... standard charts usually look like this:
    # (Actually, let's verify if `server.httproute` exists in the chart values default?
    # User mentioned "argocd chart supports Gateway API HTTPRoute".
    # I will try the common params).
    #
    # Wait, simple way: disable ingress here and use `configs.params`... NO.
    # The chart usually has `server.httpRoute` block.
    # Let's try:
    #
    # server:
    #   httpRoute:
    #     enabled: true
    #     parentRefs:
    #     - name: external
    #       namespace: argo
    #     hostnames:
    #     - argocd.local
    #



argo-workflows:
  enabled: true
  fullnameOverride: argo-workflows
  authModes: ["server"]
  server:
    extraArgs:
    - --auth-mode=server
    ingress:
      enabled: true
      annotations:
        nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
        nginx.ingress.kubernetes.io/force-ssl-redirect: "false"
      ingressClassName: "nginx"
      hosts:
        - argo-workflows.local


argo-events:
  enabled: true
  fullnameOverride: argo-events


argo-rollouts:
  enabled: true
  fullnameOverride: argo-rollouts
  dashboard:
    enabled: true
    ingress:
      enabled: true
      ingressClassName: "nginx"
      hosts:
        - argo-rollouts.local
      pathType: ImplementationSpecific
      paths:
        - /
